<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Dakotah Lambert" />
  <title>Piecewise Testable and Extensions</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Piecewise Testable and Extensions</h1>
<p class="author">Dakotah Lambert</p>
</header>
<h2 id="a-review-and-the-goal">A Review and the Goal</h2>
<p>Recall that a variety is a class of monoids closed under taking products, submonoids, and quotients. The union and intersection operations can be implemented as a monoid product followed by taking a submonoid and then a quotient by the appropriate new Myhill relation. So classes defined by monoid varieties are closed under these operations. A language and its complement share the same monoid, so these classes are closed under the Boolean operations.</p>
<p>So far we have discussed monoids in the finite (regular), aperiodic (star-free), trivial (1), and semilattice (CB) varieties. We have also discussed a general method for making a semigroup-based class generalizing the monoid-based one: if ğ• is a variety of monoids, then ğ‹ğ• is a variety of semigroups defined by ğ‘’â¢ğ‘†â¢ğ‘’âˆˆğ•. This gave us generalized definite (from 1) and locally testable (from CB). For each ğ‹ğ• class, there is a tier-based variant, ğ“ğ‹ğ•, characterized by the language being in ğ‹ğ• after removing all of the symbols that form self-loops everywhere. Note that there should also be an ğŒğ“ğ‹ğ• which is actually closed under the Boolean operations, but these multi-tier classes do not appear in our tables.</p>
<p>The following table summarizes the classes discussed so far, as well as the three new ones from this session. Inclusions hold downward (GD is contained in LT for example) and leftward (CB is contained in LT). One diagonal is then guaranteed (LT contains 1), but the other is not (CB and GD are incomparable).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">ğ•</th>
<th style="text-align: center;">ğ‹ğ•</th>
<th style="text-align: center;">ğ“ğ‹ğ•</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">ğ…ğ¢ğ§</td>
<td style="text-align: center;">Reg</td>
<td style="text-align: center;">?</td>
<td style="text-align: center;">?</td>
</tr>
<tr class="even">
<td style="text-align: center;">ğ€ğ©</td>
<td style="text-align: center;">SF</td>
<td style="text-align: center;">?</td>
<td style="text-align: center;">?</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ğ‰</td>
<td style="text-align: center;">PT</td>
<td style="text-align: center;">LP</td>
<td style="text-align: center;">TLP</td>
</tr>
<tr class="even">
<td style="text-align: center;">ğ‰<sub>ğˆ</sub></td>
<td style="text-align: center;">CB</td>
<td style="text-align: center;">LT</td>
<td style="text-align: center;">TLT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ğŸ</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">GD</td>
<td style="text-align: center;">TGD</td>
</tr>
</tbody>
</table>
<h2 id="greens-relations">Greenâ€™s Relations</h2>
<p>Named for James Alexander Green, Greenâ€™s relations are commonly used to describe the structure of semigroups and monoids. We only really need one of them right now, but weâ€™ll introduce three. Represented by fancy L (ğ“›), R (ğ“¡), and J (ğ“™), they are defined as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">ğ‘ğ“›ğ‘</td>
<td style="text-align: center;">ğ‘€â¢ğ‘=ğ‘€â¢ğ‘</td>
</tr>
<tr class="even">
<td style="text-align: center;">ğ‘ğ“¡ğ‘</td>
<td style="text-align: center;">ğ‘â¢ğ‘€=ğ‘â¢ğ‘€</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ğ‘ğ“™ğ‘</td>
<td style="text-align: center;">ğ‘€â¢ğ‘â¢ğ‘€=ğ‘€â¢ğ‘â¢ğ‘€</td>
</tr>
</tbody>
</table>
<p>There is a lot to be said about these relations, but all we need is that a monoid is <strong>trivial under</strong> a relation â“ iff ğ‘â“ğ‘ holds in all and only those cases where ğ‘=ğ‘. As an aside, there is an ğ“— relation where star-free is ğ“—-trivial.</p>
<h2 id="piecewise-testable">Piecewise Testable</h2>
<p>The base class of this session is the piecewise testable (PT) class, characterized by ğ“™-trivial monoids. That is, ğ‘ğ“™ğ‘ iff ğ‘=ğ‘, or in other words ğ‘€â¢ğ‘â¢ğ‘€=ğ‘€â¢ğ‘â¢ğ‘€ iff ğ‘=ğ‘. These are the languages in which there is some integer ğ‘˜ for which the language is defined by Boolean combinations of subsequences of length up to ğ‘˜. That is, if two words have the same set of subsequences of length up to ğ‘˜, then they must be treated identically, both in or both out. A subsequence is like a substring but using general precedence instead of adjacency.</p>
<p>As an exercise, one might show that all semilattices with identity (commutative and idempotent monoids) are ğ“™-trivial. This would prove the containment of the CB row in the newly generated PT row.</p>
<p>For now, let us see an example of a piecewise testable language. This one is defined as follows:</p>
<ul>
<li>nothing follows a â€œcâ€</li>
<li>no two things follow a â€œbâ€, and</li>
<li>having an â€œaâ€¥câ€ subsequence implies having a â€œbâ€</li>
</ul>
<p><img src="./pt-non-ra.svg" alt="A state machine of four states. All are accepting, and state 1 is initial. State 1 goes to states 4, 2, and 3 on a, b, and c respectively. State 2 goes to state 3 on everything. State 3 itself has no out-edges. State 4 has a self-loop on a, and goes to 2 on b." /><br /> Its syntactic monoid is shown below both as a graph and as a table.<br /> <img src="./pt-non-ra-mon.svg" alt="The syntactic monoid of the above. The full table is provided below." /></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Î»</th>
<th style="text-align: center;">a</th>
<th style="text-align: center;">b</th>
<th style="text-align: center;">c</th>
<th style="text-align: center;">aa</th>
<th style="text-align: center;">ab</th>
<th style="text-align: center;">ba</th>
<th style="text-align: center;">ca</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Î»</td>
<td style="text-align: center;">Î»</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">aa</td>
<td style="text-align: center;">ab</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ca</td>
</tr>
<tr class="even">
<td style="text-align: center;">a</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">aa</td>
<td style="text-align: center;">ab</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">aa</td>
<td style="text-align: center;">ab</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ca</td>
</tr>
<tr class="odd">
<td style="text-align: center;">b</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
</tr>
<tr class="even">
<td style="text-align: center;">c</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
</tr>
<tr class="odd">
<td style="text-align: center;">aa</td>
<td style="text-align: center;">aa</td>
<td style="text-align: center;">aa</td>
<td style="text-align: center;">ab</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">aa</td>
<td style="text-align: center;">ab</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ca</td>
</tr>
<tr class="even">
<td style="text-align: center;">ab</td>
<td style="text-align: center;">ab</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ba</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
</tr>
<tr class="even">
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ca</td>
</tr>
</tbody>
</table>
<p>There are no self-loops on the identity, so we know we canâ€™t need a tier-based class to describe this. (It is in fact locally testable, strictly local even, if you want to verify that.) We can show that it is piecewise testable, in one of two ways. First, we could construct the two-sided ideal of every element. For each ğ‘¥, find ğ‘¥â¢ğ‘€ (the set of elements in the ğ‘¥ row of the table), then then find ğ‘€â¢ğ‘¥â¢ğ‘€ as the union of the columns of each result.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">ğ‘¥</th>
<th style="text-align: center;">ğ‘¥â¢ğ‘€</th>
<th style="text-align: center;">ğ‘€â¢ğ‘¥â¢ğ‘€</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Î»</td>
<td style="text-align: center;">{Î»,a,b,c,aa,ab,ba,ca}</td>
<td style="text-align: center;">{Î»,a,b,c,aa,ab,ba,ca}</td>
</tr>
<tr class="even">
<td style="text-align: center;">a</td>
<td style="text-align: center;">{a,aa,ab,ca}</td>
<td style="text-align: center;">{a,aa,ab,ba,ca}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">b</td>
<td style="text-align: center;">{b,ba,ca}</td>
<td style="text-align: center;">{b,ab,ba,ca}</td>
</tr>
<tr class="even">
<td style="text-align: center;">c</td>
<td style="text-align: center;">{c,ca}</td>
<td style="text-align: center;">{c,ba,ca}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">aa</td>
<td style="text-align: center;">{aa,ab,ca}</td>
<td style="text-align: center;">{aa,ab,ca}</td>
</tr>
<tr class="even">
<td style="text-align: center;">ab</td>
<td style="text-align: center;">{ab,ba,ca}</td>
<td style="text-align: center;">{ab,ba,ca}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ba</td>
<td style="text-align: center;">{ba,ca}</td>
<td style="text-align: center;">{ba,ca}</td>
</tr>
<tr class="even">
<td style="text-align: center;">ca</td>
<td style="text-align: center;">{ca}</td>
<td style="text-align: center;">{ca}</td>
</tr>
</tbody>
</table>
<p>This however requires a ton of work, computing all of these ideals for every element. (It is however the method that <code>plebby</code> and the LTK currently uses.)</p>
<h2 id="a-shortcut">A Shortcut</h2>
<p>First, let us define a notation. ğ‘€<sub>ğ‘’</sub> is the submonoid of ğ‘€ generated by the set {ğ‘” : ğ‘’=ğ‘¢â¢ğ‘”â¢ğ‘£ for some ğ‘¢ and ğ‘£}. Recall that the elements of the monoid are equivalence classes of strings. Intuitively, ğ‘€<sub>ğ‘’</sub> is the set of elements that include words made up of only letters that appear in some word in ğ‘’. This is dealing with a restricted alphabet, just like tier-based things.</p>
<p>One can show that a language is ğ“™-trivial iff for all idempotents ğ‘’, it holds that ğ‘€<sub>ğ‘’</sub>â¢ğ‘’â¢ğ‘€<sub>ğ‘’</sub>=ğ‘’. Note in our table above we have only three idempotents: ğ¸(ğ‘€)={âŸ¦Î»âŸ§,âŸ¦aaâŸ§,âŸ¦caâŸ§}. We still need to construct the two-sided ideals ğ‘€â¢ğ‘¥â¢ğ‘€ for each letter ğ‘¥, but we donâ€™t have to do this for the entire monoid. Notice that âŸ¦aaâŸ§ is in the two-sided ideal of âŸ¦aâŸ§, but not of any other letter. So the subalphabet we use is just {a}. And âŸ¦Î»âŸ§ is not in any two-sided ideals, so its subalphabet is âˆ…. And âŸ¦caâŸ§ is a zero, so its subalphabet is the entire alphabet.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">ğ‘’</th>
<th style="text-align: center;">ğ‘€<sub>ğ‘’</sub></th>
<th style="text-align: center;">ğ‘€<sub>ğ‘’</sub>â¢ğ‘’</th>
<th style="text-align: center;">ğ‘€<sub>ğ‘’</sub>â¢ğ‘’â¢ğ‘€<sub>ğ‘’</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Î»</td>
<td style="text-align: center;">{Î»}</td>
<td style="text-align: center;">{Î»}</td>
<td style="text-align: center;">{Î»}</td>
</tr>
<tr class="even">
<td style="text-align: center;">aa</td>
<td style="text-align: center;">{Î»,a,aa}</td>
<td style="text-align: center;">{aa}</td>
<td style="text-align: center;">{aa}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ca</td>
<td style="text-align: center;">ğ‘€</td>
<td style="text-align: center;">{ca}</td>
<td style="text-align: center;">{ca}</td>
</tr>
</tbody>
</table>
<p>Now we see that ğ‘€<sub>ğ‘’</sub>â¢ğ‘’â¢ğ‘€<sub>ğ‘’</sub>=ğ‘’ for all idempotents ğ‘’, verifying piecewise testability with much less work.</p>
<p>One can prove that in a PT languageâ€™s syntactic monoid, all cycles are self-loops and all idempotents have self-loops on every symbol that reaches them. The implication is that for an alphabet Î£, there can be only 2<sup>|Î£|</sup> idempotents. So for an alphabet of size 3 like weâ€™ve mostly been dealing with, there can only be up to 8 idempotents no matter how big the monoid is.</p>
<h2 id="the-locally-version-of-pt">The â€œLocallyâ€ Version of PT</h2>
<p>Replace ğ‘€ by ğ‘’â¢ğ‘†â¢ğ‘’ in the definition of piecewise testable in order to get its â€œlocallyâ€ variant, here called LP. Note that it may not be the case that every ğ‘ is in ğ‘’â¢ğ‘†â¢ğ‘’, so we need to restrict ourselves to elements of the form ğ‘’â¢ğ‘â¢ğ‘’. But then a language is LP iff ğ‘’â¢ğ‘†â¢ğ‘’â¢ğ‘’â¢ğ‘â¢ğ‘’â¢ğ‘’â¢ğ‘†â¢ğ‘’=ğ‘’â¢ğ‘†â¢ğ‘’â¢ğ‘’â¢ğ‘â¢ğ‘’â¢ğ‘’â¢ğ‘†â¢ğ‘’ implies ğ‘’â¢ğ‘â¢ğ‘’=ğ‘’â¢ğ‘â¢ğ‘’ for all idempoents ğ‘’ and for all elements ğ‘ and ğ‘.</p>
<p>We didnâ€™t discuss an example of this, but the language requiring an â€œabâ€ substring eventually followed by a â€œcâ€, shown below as a DFA, is in this class. One may as an exercise construct its 12-state monoid and verify that it is not in TLT or anything that contains, nor is it in PT, but it is in LP. Each local subsemigroup is ğ“™-trivial. <br /> <img src="./lp.svg" alt="A state machine of four states. State 1, the initial state, has self-loops on b and c while going to 2 on a. State 2 loops on a, goes to 3 on b, and goes to 1 on c. State 3 loops on a and b while going to 4 on c. State 4 is an accepting sink." /></p>
<p>We havenâ€™t proven for sure that LP is â€œpiecewise-locally testableâ€, but if it is, then it would be those languages where words with the same set of ğ‘—-subsequences made up of ğ‘˜-blocks (subsequences of substrings) are treated identically, both in or both out.</p>
<p>Oh and thereâ€™s a tier-based class, TLP. We know how those go. Take the above language and stick self-loops on â€œdâ€ everywhere and you have a member of TLP that isnâ€™t in LP.</p>
<h2 id="summary">Summary</h2>
<p>By this point, weâ€™ve reached what we believe to be an upper bound of complexity on phonological surface patterns. Stress patterns for example are all contained in a subclass of LP. There are more classes above where we have left off, including those defined by first-order logics restricted to two variables. We also have not discussed locally threshold testable, which corresponds to first-order definability with successor alone. This class is contained by LP and contains LT, so it would be somewhere in the middle there. Other classes might be discussed as the need arises, but for now we end the exploration of stringsets and move on to functions.</p>
<p>Note that there are many possible classes between the rows of our table. Any time you propose a class that is describable by a monoid variety, it will have a place in the leftmost column. The â€œlocallyâ€ variant will then exist, and its tier-based variant as well. By another generalization we have not yet encountered, there will also be new rows which will continue to spiral upward. In other words, proposing one class now yields several others.</p>
</body>
</html>
